<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[macbookpro 电池鼓包 手动冒死刺穿操作]]></title>
    <url>%2F2019%2F04%2F09%2F%E6%89%8B%E5%8A%A8%E5%86%92%E6%AD%BB%E5%88%BA%E7%A9%BF%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[前几天吧天气开始热了, 同时也觉得电脑越来越热, 这电脑15年底买的用到现在一直没拆开过, 想把电脑拆了看看, 才发现原来一直用的这台15款年中macbookpro15寸的底部螺丝跟我另外一台11款年初的不一样了, 用的是五星型的螺丝, 而11款年初使用的是六星形的.马上去淘宝买了工具套装, 想想硅脂应该也要换了吧, 都买了一共76.工具到了开始拆机, 发现拆开底部右下方第一粒螺丝后, 底盖就几乎要爆出来, 都是电池撑的.这是底部螺丝全拆完的样子, 好像少女发育一样(😍😍😍)摸了一下软软的, 目测是充了气.当时真的是好害怕这些电池会炸了, 以前给6s换电池也领教过了, 电池牢牢地黏在手机上, 我就瞎掰, 结果把电池保护的里层弄穿了一点, 马上起火花😂.一轮百度以后, 发现好多老大哥都是直接戳了放气的.我也鼓起勇气干了, 把老婆化妆用的挤痘痘那根针拿来了, 那根东西挺长的, 我就躲在椅子后面跪着把手伸得老长去戳它.一共有六个, 戳了第一个就发现了其实安全性还是挺高的😂, 经过之前的百度发现, 锂电池在过充(一直插电用笔记本其实是不好的习惯)的情况下会产生气体. 这鼓包里面摸起来还是软软的其实是因为里面都是气体, 而图中看到的鼓起来, 其实是因为电池的包装是密封的, 无法泄出锂电池产生的气体而鼓起来了.所以, 标题党了, 危险是有的, 但不至于冒死, 刺穿的只是电池的包装, 使其放气. 否则充气的电池极有可能会导致其他结构的损坏(例如触控板弹起), 甚至因气压过剩而爆炸.但是需要注意的是, 除了这种位于包装层面的充气鼓包的情况, 不排除还有电池内部的鼓包的情况, 所以, 操作时, 一定要注意区分, 鼓包是软鼓包还是硬鼓包, 如果是硬鼓包, 就千万不能擅自操作了. 刺穿以后, 用透明胶封上, 防止漏液 继续往里面拆, 记录一下螺丝位置, 好脏. 然后涂上硅脂, 这手残..涂得太厚了 开机, 温度没有大幅下降, 风扇转数是明显的比以前低了, 以前一开机什么没动就是4000起步. 上图是开机以后, 跑了chrome, vscode, xcode, xcode simulator, 以往的话就是6000转+, 60℃+了]]></content>
  </entry>
  <entry>
    <title><![CDATA[集成了友盟app分析,debug时无法打印崩溃原因的解决]]></title>
    <url>%2F2019%2F04%2F02%2F%E9%9B%86%E6%88%90%E4%BA%86%E5%8F%8B%E7%9B%9Fapp%E5%88%86%E6%9E%90-debug%E6%97%B6%E6%97%A0%E6%B3%95%E6%89%93%E5%8D%B0%E5%B4%A9%E6%BA%83%E5%8E%9F%E5%9B%A0%E7%9A%84%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[集成友盟数据分析以后, 所有的崩溃都没有打印, 烦, 百度了好久, 大多都说只要设置[MobClick setCrashReportEnabled:NO];问题就能解决的了.并没有啊!!!!去友盟官网找了一下, 从它们的文档中找到了关键的一句:123[MobClick setCrashReportEnabled:NO]; // 关闭Crash收集// **注意：**// 此函数需在common sdk初始化前适用，默认是开启状态 好吧, 试了一下, 把本来的代码:12[UMConfigure initWithAppkey:KUMengAppKey channel:nil];[MobClick setCrashReportEnabled:!IS_DEBUG]; 改为:12[MobClick setCrashReportEnabled:!IS_DEBUG]; // 这一行在 sdk 初始化前执行[UMConfigure initWithAppkey:KUMengAppKey channel:nil]; // 初始化友盟sdk OK, 奔溃也有详细的打印了.]]></content>
  </entry>
  <entry>
    <title><![CDATA[sqlalchemy.orm.exc.StaleDataError]]></title>
    <url>%2F2019%2F03%2F21%2Fsqlalchemy-orm-exc-StaleDataError%2F</url>
    <content type="text"><![CDATA[今天在对数据库做数据删除操作时遇到了这么个错误:sqlalchemy.orm.exc.StaleDataError:DELETE statement on table &#39;xxx&#39; expected to delete x row(s); Only x 0 were matched 数据结构如下:12345A, B, C 三张表 + B_C 中间表A.Bs (one to many)A.Cs (one to many)B.C (many to many)C.B (many to many) B 对 C 的引用是这么写的:1cs = db.relationship(&apos;C&apos;, secondary=B_C) 另外也写了 C 对 B 的引用:1bs = db.relationship(&apos;B&apos;, secondary=B_C) 我删除的数据是 A, 而 A 对 B,C 都是 级联删除关系. 抛出错误后, 错误最后一行发生在这里:12File &quot;/Users/siu/.virtualenvs/project_name/lib/python3.7/site-packages/sqlalchemy/orm/dependency.py&quot;, line 1200, in _run_crud result.rowcount, 进去看了一下, 打断点, 发现这个抛出错误所在的 _run_crud 方法跑了两遍, 其中 result.rowcount 第一次是有值, 而且值是准确的, 第二次是0123456789101112131415161718192021222324252627282930def _run_crud( self, uowcommit, secondary_insert, secondary_update, secondary_delete): connection = uowcommit.transaction.connection(self.mapper) if secondary_delete: associationrow = secondary_delete[0] statement = self.secondary.delete( sql.and_( *[ c == sql.bindparam(c.key, type_=c.type) for c in self.secondary.c if c.key in associationrow ] ) ) result = connection.execute(statement, secondary_delete) if ( result.supports_sane_multi_rowcount() ) and result.rowcount != len(secondary_delete): raise exc.StaleDataError( "DELETE statement on table '%s' expected to delete " "%d row(s); Only %d were matched." % ( self.secondary.description, len(secondary_delete), result.rowcount, ) ) 我猜想是不是因为 同时在 B/C 中写了对 C/B 的引用, 于是, 改了一下123# 注释其中一个# cs = db.relationship(&apos;C&apos;, secondary=B_C)bs = db.relationship(&apos;B&apos;, secondary=B_C, backref=db.backref(&apos;cs&apos;)) 于是, 顺利删除了 A. 另外也记录一下:在声明 many to many / one to many / one to one 字段时, 赋值 lazy 为 &#39;dynamic&#39;, 如:1bs = db.relationship(&apos;B&apos;, secondary=B_C, backref=db.backref(&apos;cs&apos;), lazy=&apos;dynamic&apos;) 在获取 bs = c.bs 时, bs 不是一个 B 的集合(数组), 而是一个 Query 对象. 同时, 也可以为被 backref 的字段添加动态引用属性:1bs = db.relationship(&apos;B&apos;, secondary=B_C, backref=db.backref(&apos;cs&apos;, lazy=&apos;dynamic&apos;), lazy=&apos;dynamic&apos;) 这样 cs = b.cs, cs 也是一个 Query 对象, 而不是 C 的集合.如要获取到 C 的集合, 就要通过查询来获取 cs = b.cs.all() 推荐一篇关于sqlalchemy数据关系的教程:SQLAlchemy ORM教程之三：Relationship]]></content>
  </entry>
  <entry>
    <title><![CDATA[Flask学习笔记:Request和Response]]></title>
    <url>%2F2018%2F06%2F01%2FFlask%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Request%E5%92%8CResponse%2F</url>
    <content type="text"><![CDATA[Request:HTTP编码格式从 request 对象中获取POST请求参数12345@app.route('/app/login',methods = ['POST'])def app_login(): if request.method == 'POST': username = request.form.get('username') password = request.form.get('password') JSON编码格式12345@app.route('/app/login',methods = ['POST'])def app_login(): if request.method == 'POST': username = request.get_json().get('username') password = request.get_json().get('password') ResponseJSON编码格式1# return json.jsonify(dict/list/tuple) 另外,通过自定义响应类, 还可以将一些繁琐的任务简单化此处参考文章: 如何自定义Flask中的响应类（译文） 以及 Flask设置返回json格式数据自定义 response 类1234567from flask import Flask, Responseclass MyResponse(Response): # 定义一个继承自Response的对象 passapp = Flask(__name__)app.response_class = MyResponse # 告诉 app 你自定义的 response 类型 如果直接在返回响应体中传入 dict/list 等内容, Response 是无法解析的123return Response(dict(abc='abc', def='def'))# 以上这样返回响应体是会报错的:TypeError: 'dict' object is not callable 利用自定义的 response 类, 实现自动返回 JSON 响应体Response()传入的参数中, 所有不能处理的数据，都由 force_type() 方法尝试处理后，再决定报错或通过。123456class MyResponse(Response): @classmethod # 重写 force_type() 类方法, 拦截并判断报错的参数类型 def force_type(cls, rv, environ=None): if isinstance(rv, dict): rv = jsonify(rv) return super(MyResponse, cls).force_type(rv, environ)]]></content>
      <tags>
        <tag>python</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录一下ffmpeg的静态编译以及如何在项目中以单进程异步线程执行ffmpeg命令]]></title>
    <url>%2F2018%2F05%2F30%2F%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8Bffmpeg%E7%9A%84%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BB%A5%E5%8D%95%E8%BF%9B%E7%A8%8B%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8Cffmpeg%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[上一篇文章也有提到, 将动态库加入到项目中使用实在并不是上策, 所以有了这个静态库编译并在项目中使用的实践记录.可能网上很多地方都有相似的教程和说明, 所以在这里我打算尽可能说一些别人没说过的.(其实是我找不到的😂) 开始之前说明一下为什么我认为将ffmpeg编译的动态库加入到项目中并不是上策: 包会相对的大. 如上一篇所说, 要对编译出来的可执行文件进行重定向 rpath 操作. 动态包太多导致过程太过繁琐. 由于我的需求主要是以 ffmpeg 做转换操作, 希望可以在界面上实时地看到转换过程, 是否出错, 可以好像使用 Terminal 一样, 对错误的行有针对性的颜色显示. 如图 而如果使用 NSTask 执行 ffmpeg, 我并不能通过 NSTask 准确地捕获到 ffmpeg 执行期间每行输出命令的level.这里说的 level 是 ffmpeg 中 libavutil/log.h 中定义的一系列宏定义, 包括 AV_LOG_ERROR, AV_LOG_WARNING, AV_LOG_VERBOSE 等等.而如果我直接用 ffmpeg.c 中的 main() 函数执行 ffmpeg 命令, 我不仅可以准确地捕获每行输出的 level, 还可以通过 main() 函数的返回, 判断到整个过程是否顺利完成. A.编译过程不再赘述, 值得注意的是编译的配置1--prefix=/Users/username/targetPath --disable-doc --enable-pic --enable-cross-compile --enable-pthreads --enable-version3 --enable-nonfree --disable-shared --enable-static --enable-hardcoded-tables --cc=clang --host-cflags= --host-ldflags= --enable-gpl --enable-libfdk-aac --enable-libmp3lame --enable-libx264 --enable-libx265 --enable-libxvid --enable-opencl --enable-videotoolbox --enable-audiotoolbox --disable-lzma 其中 --disable-shared 和 --enable-static 分别是指: 不编译为动态库, 编译为静态库 --disable-programs 是指不生成可执行文件(ffmpeg, ffprobe, ffplay 等) B.将编译出来的两个文件夹, include,lib 加入项目, 并加入相关依赖库, 编译通过.相关依赖库如图这里要注意的是, 记得加入你需要的第三方依赖库, 不然编译会报错, 就如上面编译配置中我加入了 --enable-libx265, 那么就去libx265的开发官网下他们的 libx265.a.不过我不是去他们官网下载的, 哈哈哈哈, 我是用的 homebrew 在电脑上另外装了 ffmpeg, homebrew 将 下载ffmpeg, 编译ffmpeg, 下载相关依赖库, 搭建ffmpeg环境 四大工作都做好了, 如无意外可以在 /usr/local/Cellar 文件夹下找到, 找到后将相关的 .a 文件加入到项目即可. C.将 ffmpeg 源代码中的 fftools 中以下一坨文件加入项目: ffmpeg.c ffmpeg.h cmdutils.c cmdutils.h ffmpeg_cuvid.c ffmpeg_filter.code ffmpeg_hw.c ffmpeg_opt.c ffmpeg_videotoolbox.c 编译, 然后是一定会报错的. 各种找不到 #include &quot;谁谁谁&quot; , 好可怕对吧. 这些报错真是把我吓尿了, 后来我大概是做了这些事: 尽可能不对 找不到的 #include xxx 做 注释/删除, 因为可能会涉及更多依赖定义找不到, 找不到的话就去 ffmpeg 的源码中去拉取.例如 #include &quot;libavutil/thread&quot; 说找不到, 那就去 ffmpeg 源码 中去拉. #include &quot;config.h&quot; 文件找不到, 我就去 ffmpeg 源码去拉, 反正想要的都在 ffmpeg 的源码里.如图 我还记得我编译出来的 lib 文件夹中并没有 libswresample 相关的文件夹, 也就是意味着, 我编译出来要用的功能是用不着 libswresample 这个模块内容的, 那么我就直接把所有说找不到 #include &quot;libswresample/xxxx&quot; 的都 注释/删除 掉, 甚至将代码中实际使用到的相关报错都注释掉. 反正大胆操作就对了. 要不就拖到项目, 不行就注释掉. 如果最后不再跟你说找不到 #include &quot;xxxxx&quot; 了, 到了链接那一步出错, 那几乎 80% 的情况是少了某些依赖库.我记得在我步骤 B 中是顺利编译的, 到了步骤 C, 加入了 fftools 文件夹以下的那坨文件后, 在链接状态中报错, 隐约记得是 &quot;_clxxxxxx&quot; 方法找不到了, 那就加入了 OpenCL.framework, 就好了. 如果各种库加上了, 编译时依然是在链接的那一步有问题, 我偷偷告诉你, ffmpeg.c 中有个 main() 函数, 一个项目中(可执行文件)有且只能存在一个 main() 函数. 把 ffmpeg.c 中的 mian() 函数改名, 例如 ffmpeg_main() 之类的. D.走过了ABC后, 编译顺利通过, 就是成功了一半了. 接下来就是用 ffmpeg_main() 函数执行命令.1234567891011121314151617- (void)executeCommand:(NSArray&lt;NSString *&gt; *)commands&#123; int argc = (int)commands.count; char** argv=(char**)malloc(sizeof(char*)*argc); for(int i=0; i&lt;argc; i++)&#123; argv[i] = (char*)malloc(sizeof(char)*1024); strcpy(argv[i],[[commands objectAtIndex:i] UTF8String]); &#125; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; int rec = ffmpeg_main(argc, argv); for (int i=0;i&lt;argc;i++) free(argv[i]); free(argv); NSLog(@"rec = %i",rec); &#125;);&#125; 我就是这么干的.如果你直接这么干就出问题了. 你会发现命令确实可以跑起来, 但是完毕了, app就自动退出.问题出在 cmdutils.c 中的 exit_program() 函数, 其中的 exit(ret) 一行.ffmpeg 每次执行命令时, 都会创建一个新的进程去执行, 当命令执行完毕, 就会调 exit_program() 做一系列的清理工作, 然后 exit(ret) 直接把进程杀死.macos以及iOS的app都是一般来说都是以单进程的设计概念为主, 尤其是非越狱的 iOS 更是没有多进程的概念, 这也能解释了, 为什么当命令执行完毕, app就自动退出. 那就先注释掉 exit(ret) 这一行, 使命令执行完毕, 也不用杀掉进程.再次运行命令 ffmpeg(就这个简单的命令而已) , 出错, 依稀记得是 访问了某个空数组越界的错误.分析一下 ffmpeg.c 中被改名为 ffmpeg_main() 的 main() 函数,如图:由于我要求执行的命令只是简单的 ffmpeg, 所以函数执行到上图中 exit_program(1) 处就应该结束, 如果 exit() 那一行代码没有被注释掉, 那么, 根本不可能继续执行下去.那么原因大概就知道了.所以, 我将 exit_program() 函数修改了一下(头文件和实现都要修改), 改为:1234567int exit_program(int ret)&#123; if (program_exit) program_exit(ret);// exit(ret); return ret;&#125; 并且在 ffmpeg() 函数中的所有 exit_program(xxx) 都改为 return exit_program(xxx), 使 ffmpeg() 函数执行到 exit_program(xxx) 直接结束, 不再往下走. 但是问题依旧!!即使有了 return exit_program(xxx), 函数还是继续往下走, 百度一下, 找到了问题出现的原因.原来是 cmdutils.h 文件中 exit_program() 函数末尾的 av_noreturn 修饰导致 exit_program() 函数被合法地认定为没有返回, 所以即使在外部调用 return exit_program(xxx), 都无法正常地退出函数.av_noreturn 的详细解释请参考: ATTRIBUTE 你知多少？ 那么几乎可以认定, 这个 av_noreturn 修饰, 只是为了 exit() 函数存在而服务的, 现在 exit() 不存在了, 那我就大胆把它删掉了.后来还根据雷神的提示, 在 ffmpeg.c 中 ffmpeg_cleanup() 函数的末尾 加上各种变量的清零操作:1234567nb_frames_dup = 0;nb_frames_drop = 0;nb_filtergraphs = 0;nb_input_files = 0;nb_input_streams = 0;nb_output_files = 0;nb_output_streams = 0; 然后顺利运行. E.上面提到了, 我需要准确地捕获到每一个 ffmpeg 的输出日志, 并且可以好像 Terminal 执行 ffmpeg 一样输出的日志根据不同的log_level显示不同的颜色.具体可以去看看 ffmpeg 源码中 libavutil/log.c 是怎么实现 av_log() 函数的, 这里简单说一下, 大概就是使用 vsnprintf() 组合一下输出的字符串, 然后再根据函数的参数 int level 设置输出的字体颜色.如果我们要插手 av_log 方法来达到需求, 那不仅仅麻烦, 还更进一步地破坏了 ffmpeg 的原生代码, 其实, ffmpeg 提供了一个 av_log_set_callback(void (*callback)(void*, int, const char*, va_list)) 函数, 只要传入一个 callback 函数的地址, 那么该函数就会接受所有 av_log 的回调. 123456789101112void FFLogCallBackFunc(void *ptr, int level, const char *fmt, va_list vl)&#123; char o[1024]; vsnprintf(o, 1024, fmt, vl); NSString *output_desc = [NSString stringWithUTF8String:o]; NSLog(@"output_desc = %@\nlevel = %i",output_desc,level);&#125;int main(int argc, const char * argv[]) &#123; av_log_set_callback(&amp;FFLogCallBackFunc); return 0;&#125; F.目前为止, 执行媒体格式重新封装, 跨文件封装新的媒体文件, 对音视频字幕流的转码, 对视音频字幕流重新配置一些基础的参数例如采样率比特率视频的scale等都没有任何问题. 如遇到任何问题, 就在这里继续 GHIJK…]]></content>
      <tags>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[偶遇.dylib]]></title>
    <url>%2F2018%2F04%2F24%2F%E5%81%B6%E9%81%87-dylib%2F</url>
    <content type="text"><![CDATA[以下所说的并不是 ffmpeg 引用到项目中的正确方法, 请不要模仿. 一切的一切都要从编译 ffmpeg, 并在 mac os 项目上引用 ffmpeg 说起. 我是用的 homebrew 装的 ffmpeg, 路径是 /usr/local/Cellar 里面发挥主要用处的有bin lib include 三个文件, bin 存放有 ffmpeg, ffprobe 等可执行文件, include 都是头文件, lib 里面放的就是我所偶遇的一大堆 .dylib 以及 .a 库文件. 因为想要做个 ffmpeg 给视频转码的项目, 要将 ffmpeg 引入, 在引入这个阶段, 我走了捷径, 可以说是搭上了穿梭机(其实是特傻😂).我直接从 /usr/local/Cellar 把 lib include 两个文件拉到项目中, 在项目中用到了 avformat avcodec 等等的类, 一切看起来都非常的顺利, 直到我从 ffmpeg 3.4 转到了 4.0 版本…我通过 brew update &amp;&amp; $ brew reinstall ffmpeg --with-x265 命令将 ffmpeg 升级到 4.0版本, 再打开项目, 一运行就报如下错误:12dyld: Library not loaded: /usr/local/opt/ffmpeg/lib/libavdevice.58.dylib Reason: image not found 思考一下, 很大的原因是出在这一堆 .dylib 库中. 报错也让我感到很奇怪, 明明已经将这一堆 .dylib 放到项目中, 怎么 not loaded 的路径会是 /usr/local/opt/ffmpeg/lib/libavdevice.58.dylib ?? 我到 DerivedData 文件夹中找到了项目生成的 .app 文件, 发现里面并没有 Frameworks 文件夹也找不到任何打包进去 .app 的 .dylib 库.据我所知由于apple为了禁止热更新的关系, 动态库只能通过 Embedded binaries 嵌入式动态库打入到 .app 中, 我一拍大腿以为自己已经找到了解决问题的办法, 赶紧将所有 .dylib 文件加入到Embedded binaries中. 然而并没有什么撚用…我内心一直在认为, 这个 .dylib 不简单, 里面一定有什么使app在运行的时候指向那个我不想指向的地方: /usr/local/opt/ffmpeg/.在一番google过后, 这两篇文章帮了我的大忙: MacOS平台下@rpath在动态链接库中的应用Mac下动态库的install_name 其中文章 Mac下动态库的install_name 详细地指出了 install name 在 .dylib 的作用.我也用 otool -D /我的app包/content/Frameworks/libavdevice.58.dylib 查看了 libavdevice.58.dylib 的 install name, 是指向着 /usr/local/opt/ffmpeg/lib/libavdevice.58.dylib, 这也解释了为什么上面的报错路径会是这个.那么解决问题的办法就是, 使 .dylib 包的 install name 指向正确的路径(通俗解释, 如有不对感谢指出).以其中一个 .dylib 为例, 使用命令1$ install_name_tool -id @rpath/libavdevice.58.dylib 我的项目路径/lib/libavdevice.58.dylib 就将 libavdevice.58.dylib 的 install name 修改为 @rpath/libavdevice.58.dylib, 而且这个以 @rpath 修饰的 install name 针对各个引用这个 .dylib 库的项目而言是 动态的 &amp;&amp; 是由项目的 run path 决定的, 对于 @rpath @loader_path @executable_path 的区别, 具体请看 MacOS平台下@rpath在动态链接库中的应用. 上面提到了 以 @rpath 修饰的 install name 是由项目的 run path 决定的 那么我还需要在项目里 Build Settings 中 Runpath search paths 里面加入我将决定这些引入的 .dylib 库真正完整的 install name 还有更恶心人的,lib 文件夹里面有十几个这样的 .dylib 库, 这意味着, 我要重复这个 $ install_name_tool -id @rpath/libavdevice.58.dylib 我的项目路径/lib/libavdevice.58.dylib 命令十几次… 我还一度想要写个 python 脚本来完成执行这个命令十几次的任务, 尽管我傻, 但是并没至于如此. 静态编译 ffmpeg 才是出路, 当然这也是后话了. 秉承着 实践是检验真理的唯一道路 这一深深印在我心中的理念, 我手动..人肉..亲自执行了这个命令十几次, 将在项目中 lib 文件夹下的所有的 .dylib 的 install name 都执行了一次, 并且 brew uninstall ffmpeg 删除了本地的 ffmpeg 以确保不会干扰到我这个无聊的实验. 运行项目, 不再报错, ffmpeg使用正常, 使用 otool -D 命令检查 .app 包包里 /Frameworks 里面 .dylib 库的 install name 确实指向了如我所愿的位置.DONE.. 能够认识到 .dylib, 人肉执行十几次那个修改 install name 的命令, 也是值得.]]></content>
      <tags>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我是房东-项目介绍]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%88%91%E6%98%AF%E6%88%BF%E4%B8%9C-%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[我是房东 - 智能的房东租赁数据管理利器无广告，无推荐信息，纯净，高效，贴心，非商业化的房东租赁数据管理app，解放您手中的纸，笔和传统的计算器，让您有更多时间去享受诗和远方！[简单直观的界面] 通过多次的尝试和探索，一心要制定最简单而又直观的使用界面，使我是房东尽可能更易使用，让用户使用得心应手。 [无广告无推荐] 无广告，无不必要的“发现”等内容，简单高效。 [高度可定制] 各类信息高度可定制，围绕物业，房间，租客，收费项目定制您的租赁数据。房间合同期记录，押金记录。尤其是针对物业的收费项目，您需要什么收费项目，由您掌握。 [高效智能的统计方式] 收费项目可指定到目标房间，抄表统计费用或用量时可直接输入项目读数或用量，即使水电表跑到置零，也不必担心数据有误。抄表时app会自动设置或由用户自由选择上月读数到本月抄表数据中，高效贴心，用户放心。 [身份证扫描] 记录租房人信息时，可通过扫描身份证或识别身份证图片来快速录入身份证信息。 [贴心提醒] 该抄表了，抄表后若干日过去了有租户还没缴租，我是房东来提醒你。 [隐私保护] 进入后台即模糊界面，进入app密码由您来定。 [谨慎对待数据] 删除操作等都需要验证鉴定，减少误操作数据。 [强大的本地搜索功能] 想找找名为“李四”的租赁信息或房间？到搜索栏输入您想要的，就能找到你想要的。 [智能的打印功能] 只要您配备了支持 AirPrint 的打印机，利用 我是房东，就能轻松打印您想打印的租赁数据。]]></content>
      <categories>
        <category>iOS项目-我是房东</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>我是房东</tag>
      </tags>
  </entry>
</search>
