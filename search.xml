<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Flask学习笔记:Request和Response]]></title>
    <url>%2F2018%2F06%2F01%2FFlask%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Request%E5%92%8CResponse%2F</url>
    <content type="text"><![CDATA[Request:HTTP编码格式从 request 对象中获取POST请求参数12345@app.route('/app/login',methods = ['POST'])def app_login(): if request.method == 'POST': username = request.form.get('username') password = request.form.get('password') JSON编码格式12345@app.route('/app/login',methods = ['POST'])def app_login(): if request.method == 'POST': username = request.get_json().get('username') password = request.get_json().get('password') ResponseJSON编码格式1# return json.jsonify(dict/list/tuple) 另外,通过自定义响应类, 还可以将一些繁琐的任务简单化此处参考文章: 如何自定义Flask中的响应类（译文） 以及 Flask设置返回json格式数据自定义 response 类1234567from flask import Flask, Responseclass MyResponse(Response): # 定义一个继承自Response的对象 passapp = Flask(__name__)app.response_class = MyResponse # 告诉 app 你自定义的 response 类型 如果直接在返回响应体中传入 dict/list 等内容, Response 是无法解析的123return Response(dict(abc='abc', def='def'))# 以上这样返回响应体是会报错的:TypeError: 'dict' object is not callable 利用自定义的 response 类, 实现自动返回 JSON 响应体Response()传入的参数中, 所有不能处理的数据，都由 force_type() 方法尝试处理后，再决定报错或通过。123456class MyResponse(Response): @classmethod # 重写 force_type() 类方法, 拦截并判断报错的参数类型 def force_type(cls, rv, environ=None): if isinstance(rv, dict): rv = jsonify(rv) return super(MyResponse, cls).force_type(rv, environ)]]></content>
      <tags>
        <tag>python</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录一下ffmpeg的静态编译以及如何在项目中以单进程异步线程执行ffmpeg命令]]></title>
    <url>%2F2018%2F05%2F30%2F%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8Bffmpeg%E7%9A%84%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BB%A5%E5%8D%95%E8%BF%9B%E7%A8%8B%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8Cffmpeg%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[上一篇文章也有提到, 将动态库加入到项目中使用实在并不是上策, 所以有了这个静态库编译并在项目中使用的实践记录.可能网上很多地方都有相似的教程和说明, 所以在这里我打算尽可能说一些别人没说过的.(其实是我找不到的😂) 开始之前说明一下为什么我认为将ffmpeg编译的动态库加入到项目中并不是上策: 包会相对的大. 如上一篇所说, 要对编译出来的可执行文件进行重定向 rpath 操作. 动态包太多导致过程太过繁琐. 由于我的需求主要是以 ffmpeg 做转换操作, 希望可以在界面上实时地看到转换过程, 是否出错, 可以好像使用 Terminal 一样, 对错误的行有针对性的颜色显示. 如图 而如果使用 NSTask 执行 ffmpeg, 我并不能通过 NSTask 准确地捕获到 ffmpeg 执行期间每行输出命令的level.这里说的 level 是 ffmpeg 中 libavutil/log.h 中定义的一系列宏定义, 包括 AV_LOG_ERROR, AV_LOG_WARNING, AV_LOG_VERBOSE 等等.而如果我直接用 ffmpeg.c 中的 main() 函数执行 ffmpeg 命令, 我不仅可以准确地捕获每行输出的 level, 还可以通过 main() 函数的返回, 判断到整个过程是否顺利完成. A.编译过程不再赘述, 值得注意的是编译的配置1--prefix=/Users/username/targetPath --disable-doc --enable-pic --enable-cross-compile --enable-pthreads --enable-version3 --enable-nonfree --disable-shared --enable-static --enable-hardcoded-tables --cc=clang --host-cflags= --host-ldflags= --enable-gpl --enable-libfdk-aac --enable-libmp3lame --enable-libx264 --enable-libx265 --enable-libxvid --enable-opencl --enable-videotoolbox --enable-audiotoolbox --disable-lzma 其中 --disable-shared 和 --enable-static 分别是指: 不编译为动态库, 编译为静态库 --disable-programs 是指不生成可执行文件(ffmpeg, ffprobe, ffplay 等) B.将编译出来的两个文件夹, include,lib 加入项目, 并加入相关依赖库, 编译通过.相关依赖库如图这里要注意的是, 记得加入你需要的第三方依赖库, 不然编译会报错, 就如上面编译配置中我加入了 --enable-libx265, 那么就去libx265的开发官网下他们的 libx265.a.不过我不是去他们官网下载的, 哈哈哈哈, 我是用的 homebrew 在电脑上另外装了 ffmpeg, homebrew 将 下载ffmpeg, 编译ffmpeg, 下载相关依赖库, 搭建ffmpeg环境 四大工作都做好了, 如无意外可以在 /usr/local/Cellar 文件夹下找到, 找到后将相关的 .a 文件加入到项目即可. C.将 ffmpeg 源代码中的 fftools 中以下一坨文件加入项目: ffmpeg.c ffmpeg.h cmdutils.c cmdutils.h ffmpeg_cuvid.c ffmpeg_filter.code ffmpeg_hw.c ffmpeg_opt.c ffmpeg_videotoolbox.c 编译, 然后是一定会报错的. 各种找不到 #include &quot;谁谁谁&quot; , 好可怕对吧. 这些报错真是把我吓尿了, 后来我大概是做了这些事: 尽可能不对 找不到的 #include xxx 做 注释/删除, 因为可能会涉及更多依赖定义找不到, 找不到的话就去 ffmpeg 的源码中去拉取.例如 #include &quot;libavutil/thread&quot; 说找不到, 那就去 ffmpeg 源码 中去拉. #include &quot;config.h&quot; 文件找不到, 我就去 ffmpeg 源码去拉, 反正想要的都在 ffmpeg 的源码里.如图 我还记得我编译出来的 lib 文件夹中并没有 libswresample 相关的文件夹, 也就是意味着, 我编译出来要用的功能是用不着 libswresample 这个模块内容的, 那么我就直接把所有说找不到 #include &quot;libswresample/xxxx&quot; 的都 注释/删除 掉, 甚至将代码中实际使用到的相关报错都注释掉. 反正大胆操作就对了. 要不就拖到项目, 不行就注释掉. 如果最后不再跟你说找不到 #include &quot;xxxxx&quot; 了, 到了链接那一步出错, 那几乎 80% 的情况是少了某些依赖库.我记得在我步骤 B 中是顺利编译的, 到了步骤 C, 加入了 fftools 文件夹以下的那坨文件后, 在链接状态中报错, 隐约记得是 &quot;_clxxxxxx&quot; 方法找不到了, 那就加入了 OpenCL.framework, 就好了. 如果各种库加上了, 编译时依然是在链接的那一步有问题, 我偷偷告诉你, ffmpeg.c 中有个 main() 函数, 一个项目中(可执行文件)有且只能存在一个 main() 函数. 把 ffmpeg.c 中的 mian() 函数改名, 例如 ffmpeg_main() 之类的. D.走过了ABC后, 编译顺利通过, 就是成功了一半了. 接下来就是用 ffmpeg_main() 函数执行命令.1234567891011121314151617- (void)executeCommand:(NSArray&lt;NSString *&gt; *)commands&#123; int argc = (int)commands.count; char** argv=(char**)malloc(sizeof(char*)*argc); for(int i=0; i&lt;argc; i++)&#123; argv[i] = (char*)malloc(sizeof(char)*1024); strcpy(argv[i],[[commands objectAtIndex:i] UTF8String]); &#125; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; int rec = ffmpeg_main(argc, argv); for (int i=0;i&lt;argc;i++) free(argv[i]); free(argv); NSLog(@"rec = %i",rec); &#125;);&#125; 我就是这么干的.如果你直接这么干就出问题了. 你会发现命令确实可以跑起来, 但是完毕了, app就自动退出.问题出在 cmdutils.c 中的 exit_program() 函数, 其中的 exit(ret) 一行.ffmpeg 每次执行命令时, 都会创建一个新的进程去执行, 当命令执行完毕, 就会调 exit_program() 做一系列的清理工作, 然后 exit(ret) 直接把进程杀死.macos以及iOS的app都是一般来说都是以单进程的设计概念为主, 尤其是非越狱的 iOS 更是没有多进程的概念, 这也能解释了, 为什么当命令执行完毕, app就自动退出. 那就先注释掉 exit(ret) 这一行, 使命令执行完毕, 也不用杀掉进程.再次运行命令 ffmpeg(就这个简单的命令而已) , 出错, 依稀记得是 访问了某个空数组越界的错误.分析一下 ffmpeg.c 中被改名为 ffmpeg_main() 的 main() 函数,如图:由于我要求执行的命令只是简单的 ffmpeg, 所以函数执行到上图中 exit_program(1) 处就应该结束, 如果 exit() 那一行代码没有被注释掉, 那么, 根本不可能继续执行下去.那么原因大概就知道了.所以, 我将 exit_program() 函数修改了一下(头文件和实现都要修改), 改为:1234567int exit_program(int ret)&#123; if (program_exit) program_exit(ret);// exit(ret); return ret;&#125; 并且在 ffmpeg() 函数中的所有 exit_program(xxx) 都改为 return exit_program(xxx), 使 ffmpeg() 函数执行到 exit_program(xxx) 直接结束, 不再往下走. 但是问题依旧!!即使有了 return exit_program(xxx), 函数还是继续往下走, 百度一下, 找到了问题出现的原因.原来是 cmdutils.h 文件中 exit_program() 函数末尾的 av_noreturn 修饰导致 exit_program() 函数被合法地认定为没有返回, 所以即使在外部调用 return exit_program(xxx), 都无法正常地退出函数.av_noreturn 的详细解释请参考: ATTRIBUTE 你知多少？ 那么几乎可以认定, 这个 av_noreturn 修饰, 只是为了 exit() 函数存在而服务的, 现在 exit() 不存在了, 那我就大胆把它删掉了.后来还根据雷神的提示, 在 ffmpeg.c 中 ffmpeg_cleanup() 函数的末尾 加上各种变量的清零操作:1234567nb_frames_dup = 0;nb_frames_drop = 0;nb_filtergraphs = 0;nb_input_files = 0;nb_input_streams = 0;nb_output_files = 0;nb_output_streams = 0; 然后顺利运行. E.上面提到了, 我需要准确地捕获到每一个 ffmpeg 的输出日志, 并且可以好像 Terminal 执行 ffmpeg 一样输出的日志根据不同的log_level显示不同的颜色.具体可以去看看 ffmpeg 源码中 libavutil/log.c 是怎么实现 av_log() 函数的, 这里简单说一下, 大概就是使用 vsnprintf() 组合一下输出的字符串, 然后再根据函数的参数 int level 设置输出的字体颜色.如果我们要插手 av_log 方法来达到需求, 那不仅仅麻烦, 还更进一步地破坏了 ffmpeg 的原生代码, 其实, ffmpeg 提供了一个 av_log_set_callback(void (*callback)(void*, int, const char*, va_list)) 函数, 只要传入一个 callback 函数的地址, 那么该函数就会接受所有 av_log 的回调. 123456789101112void FFLogCallBackFunc(void *ptr, int level, const char *fmt, va_list vl)&#123; char o[1024]; vsnprintf(o, 1024, fmt, vl); NSString *output_desc = [NSString stringWithUTF8String:o]; NSLog(@"output_desc = %@\nlevel = %i",output_desc,level);&#125;int main(int argc, const char * argv[]) &#123; av_log_set_callback(&amp;FFLogCallBackFunc); return 0;&#125; F.目前为止, 执行媒体格式重新封装, 跨文件封装新的媒体文件, 对音视频字幕流的转码, 对视音频字幕流重新配置一些基础的参数例如采样率比特率视频的scale等都没有任何问题. 如遇到任何问题, 就在这里继续 GHIJK…]]></content>
      <tags>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[偶遇.dylib]]></title>
    <url>%2F2018%2F04%2F24%2F%E5%81%B6%E9%81%87-dylib%2F</url>
    <content type="text"><![CDATA[以下所说的并不是 ffmpeg 引用到项目中的正确方法, 请不要模仿. 一切的一切都要从编译 ffmpeg, 并在 mac os 项目上引用 ffmpeg 说起. 我是用的 homebrew 装的 ffmpeg, 路径是 /usr/local/Cellar 里面发挥主要用处的有bin lib include 三个文件, bin 存放有 ffmpeg, ffprobe 等可执行文件, include 都是头文件, lib 里面放的就是我所偶遇的一大堆 .dylib 以及 .a 库文件. 因为想要做个 ffmpeg 给视频转码的项目, 要将 ffmpeg 引入, 在引入这个阶段, 我走了捷径, 可以说是搭上了穿梭机(其实是特傻😂).我直接从 /usr/local/Cellar 把 lib include 两个文件拉到项目中, 在项目中用到了 avformat avcodec 等等的类, 一切看起来都非常的顺利, 直到我从 ffmpeg 3.4 转到了 4.0 版本…我通过 brew update &amp;&amp; $ brew reinstall ffmpeg --with-x265 命令将 ffmpeg 升级到 4.0版本, 再打开项目, 一运行就报如下错误:12dyld: Library not loaded: /usr/local/opt/ffmpeg/lib/libavdevice.58.dylib Reason: image not found 思考一下, 很大的原因是出在这一堆 .dylib 库中. 报错也让我感到很奇怪, 明明已经将这一堆 .dylib 放到项目中, 怎么 not loaded 的路径会是 /usr/local/opt/ffmpeg/lib/libavdevice.58.dylib ?? 我到 DerivedData 文件夹中找到了项目生成的 .app 文件, 发现里面并没有 Frameworks 文件夹也找不到任何打包进去 .app 的 .dylib 库.据我所知由于apple为了禁止热更新的关系, 动态库只能通过 Embedded binaries 嵌入式动态库打入到 .app 中, 我一拍大腿以为自己已经找到了解决问题的办法, 赶紧将所有 .dylib 文件加入到Embedded binaries中. 然而并没有什么撚用…我内心一直在认为, 这个 .dylib 不简单, 里面一定有什么使app在运行的时候指向那个我不想指向的地方: /usr/local/opt/ffmpeg/.在一番google过后, 这两篇文章帮了我的大忙: MacOS平台下@rpath在动态链接库中的应用Mac下动态库的install_name 其中文章 Mac下动态库的install_name 详细地指出了 install name 在 .dylib 的作用.我也用 otool -D /我的app包/content/Frameworks/libavdevice.58.dylib 查看了 libavdevice.58.dylib 的 install name, 是指向着 /usr/local/opt/ffmpeg/lib/libavdevice.58.dylib, 这也解释了为什么上面的报错路径会是这个.那么解决问题的办法就是, 使 .dylib 包的 install name 指向正确的路径(通俗解释, 如有不对感谢指出).以其中一个 .dylib 为例, 使用命令1$ install_name_tool -id @rpath/libavdevice.58.dylib 我的项目路径/lib/libavdevice.58.dylib 就将 libavdevice.58.dylib 的 install name 修改为 @rpath/libavdevice.58.dylib, 而且这个以 @rpath 修饰的 install name 针对各个引用这个 .dylib 库的项目而言是 动态的 &amp;&amp; 是由项目的 run path 决定的, 对于 @rpath @loader_path @executable_path 的区别, 具体请看 MacOS平台下@rpath在动态链接库中的应用. 上面提到了 以 @rpath 修饰的 install name 是由项目的 run path 决定的 那么我还需要在项目里 Build Settings 中 Runpath search paths 里面加入我将决定这些引入的 .dylib 库真正完整的 install name 还有更恶心人的,lib 文件夹里面有十几个这样的 .dylib 库, 这意味着, 我要重复这个 $ install_name_tool -id @rpath/libavdevice.58.dylib 我的项目路径/lib/libavdevice.58.dylib 命令十几次… 我还一度想要写个 python 脚本来完成执行这个命令十几次的任务, 尽管我傻, 但是并没至于如此. 静态编译 ffmpeg 才是出路, 当然这也是后话了. 秉承着 实践是检验真理的唯一道路 这一深深印在我心中的理念, 我手动..人肉..亲自执行了这个命令十几次, 将在项目中 lib 文件夹下的所有的 .dylib 的 install name 都执行了一次, 并且 brew uninstall ffmpeg 删除了本地的 ffmpeg 以确保不会干扰到我这个无聊的实验. 运行项目, 不再报错, ffmpeg使用正常, 使用 otool -D 命令检查 .app 包包里 /Frameworks 里面 .dylib 库的 install name 确实指向了如我所愿的位置.DONE.. 能够认识到 .dylib, 人肉执行十几次那个修改 install name 的命令, 也是值得.]]></content>
      <tags>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我是房东-项目介绍]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%88%91%E6%98%AF%E6%88%BF%E4%B8%9C-%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[我是房东 - 智能的房东租赁数据管理利器无广告，无推荐信息，纯净，高效，贴心，非商业化的房东租赁数据管理app，解放您手中的纸，笔和传统的计算器，让您有更多时间去享受诗和远方！[简单直观的界面] 通过多次的尝试和探索，一心要制定最简单而又直观的使用界面，使我是房东尽可能更易使用，让用户使用得心应手。 [无广告无推荐] 无广告，无不必要的“发现”等内容，简单高效。 [高度可定制] 各类信息高度可定制，围绕物业，房间，租客，收费项目定制您的租赁数据。房间合同期记录，押金记录。尤其是针对物业的收费项目，您需要什么收费项目，由您掌握。 [高效智能的统计方式] 收费项目可指定到目标房间，抄表统计费用或用量时可直接输入项目读数或用量，即使水电表跑到置零，也不必担心数据有误。抄表时app会自动设置或由用户自由选择上月读数到本月抄表数据中，高效贴心，用户放心。 [身份证扫描] 记录租房人信息时，可通过扫描身份证或识别身份证图片来快速录入身份证信息。 [贴心提醒] 该抄表了，抄表后若干日过去了有租户还没缴租，我是房东来提醒你。 [隐私保护] 进入后台即模糊界面，进入app密码由您来定。 [谨慎对待数据] 删除操作等都需要验证鉴定，减少误操作数据。 [强大的本地搜索功能] 想找找名为“李四”的租赁信息或房间？到搜索栏输入您想要的，就能找到你想要的。 [智能的打印功能] 只要您配备了支持 AirPrint 的打印机，利用 我是房东，就能轻松打印您想打印的租赁数据。]]></content>
      <categories>
        <category>iOS项目-我是房东</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>我是房东</tag>
      </tags>
  </entry>
</search>
